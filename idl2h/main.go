// 15 april 2015
package main

import (
	"fmt"
	"os"
	"github.com/andlabs/pgidl"
)

func typedecl(t *pgidl.Type, name string) string {
	if t == nil {
		return "void " + name
	}
	if t.IsFuncPtr {
		// TODO
	}
	s := t.Name + " "
	for i := uint(0); i < t.NumPtrs; i++ {
		s += "*"
	}
	return s + name
}

func arglist(a []*pgidl.Arg) string {
	if len(a) == 0 {
		return "void"
	}
	s := typedecl(a[0].Type, a[0].Name)
	for i := 1; i < len(a); i++ {
		s += "," + typedecl(a[i].Type, a[i].Name)
	}
	return s
}

func cfuncdecl(f *pgidl.Func, name string) string {
	fd := name + "(" + arglist(f.Args) + ")"
	return "extern " + typedecl(f.Ret, fd) + ";"
}

func genpkgfunc(f *pgidl.Func, prefix string) {
	fmt.Printf("%s\n", cfuncdecl(f, prefix + f.Name))
}

func genpkg(p *pgidl.Package) {
	for _, o := range p.Order {
		switch o.Which {
		case 0:
			genpkgfunc(p.Funcs[o.Index], p.Name)
		case 1:
//			genstruct(p.Structs[o.Index], p.Name)
		case 2:
//			geniface(p.Interfaces[o.Index], p.Name)
		}
	}
}

func main() {
	idl, errs := pgidl.Parse(os.Stdin, "<stdin>")
	if len(errs) != 0 {
		for _, e := range errs {
			fmt.Fprintf(os.Stderr, "%s\n", e)
		}
		os.Exit(1)
	}
	fmt.Printf("// generated by idl2h; do not edit\n")
	for _, p := range idl {
		genpkg(p)
	}
}
